#include <iostream>
#include <fstream>
#include <csignal>

#define MAX_NUMBER 2000000000

std::string flag{};

void floating_point_exception_handler(int signal_id)
{
    std::cout << std::endl << "****** Miniräknaren har stött på ett problem och måste avslutas. Felkod: 0x";
    std::cout << std::hex;
    for (auto it = begin(flag); it != end(flag); it++)
        std::cout << int(*it);
    std::cout << " ******"<< std::endl;
    exit(-1);
}

void stop_if_too_large(unsigned int i)
{
    while (i > MAX_NUMBER)
    {}
}

int main()
{
    signal(SIGFPE, floating_point_exception_handler);
    std::ifstream flag_file{"flag.txt"};
    if (flag_file.is_open())
    {
        flag_file >> flag;
    }
    else
    {
        std::cerr << "Kunde inte läsa flag.txt, använder fejkflagga" << std::endl;
        flag = "cratectf{fake_flag}";
    }

    unsigned int input_number;

    std::cout << "Skriv in ett tal X för att räkna ut hur mycket 100 / X blir." << std::endl
              << "OBS - vår patenterade undvik-division-med-0-algoritm kräver att du matar in talet under det du vill dividera med." << std::endl
              << "Till exempel, om du vill dela med 5 så skriver du in 4 istället:" << std::endl;

    if (std::cin.peek() == '-' || !(std::cin >> input_number))
    {
        std::cerr << "Kunde inte tolka argument som positivt heltal" << std::endl;
        return 1;
    }

    std::cout << "Kontrollerar det inmatade talet, programmet kommer att fastna för evigt om talet är för stort..." << std::endl;
    stop_if_too_large(input_number);
    std::cout << "Ser bra ut, " << input_number << " är inte större än " << MAX_NUMBER << "." << std::endl;

    input_number++;

    std::cout << "100 delat med " << input_number << " är " << 100 / input_number << "." << std::endl;
}
