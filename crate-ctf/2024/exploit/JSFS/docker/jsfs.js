function parse(path) {
    let abs = path.startsWith("/");
    if (abs) path = path.slice(1);
    return { abs, segments: path.split("/").filter(x => x && x !== ".") };
}

function join(...paths) {
    let result = parse("");
    for (let path of paths) {
        if (path.abs) result = { abs: true, segments: [...path.segments] };
        else result.segments = [...result.segments, ...path.segments];
    }
    return result;
}

function mkdir(fs, path) {
    let dir = fs;
    for (let s of path.segments) {
        if (!(s in dir)) dir[s] = new Map();
        dir = dir[s];
    }
}

function write(fs, path, contents) {
    let dir = fs;
    for (let s of path.segments.slice(0, -1)) {
        if (!(s in dir)) throw new Error("ENOENT")
        dir = dir[s];
    }
    dir[path.segments.at(-1)] = contents;
}

function get(fs, path) {
    let dir = fs;
    for (let s of path.segments.slice(0, -1)) {
        if (!(s in dir)) throw new Error("ENOENT")
        dir = dir[s];
    }
    return path.segments.length === 0 ? dir : dir[path.segments.at(-1)];
}

let fileSystem = new Map();
let workdir = parse("/");
let lines = console[Symbol.asyncIterator]();
let buffer = [];
async function readword(prompt) {
    if (buffer.length > 0) return buffer.shift();
    if (prompt) process.stdout.write(prompt);
    let { value, done } = await lines.next();
    if (done) return undefined;
    let [word, ...rest] = value.split(/\s+/);
    buffer = rest;
    return word;
}
let state = {};
while (true) {
    if ("read" in state) {
        let contents = await readword(state.read.dest + " > ");
        state[state.read.dest] = contents;
        let next = state.read.next;
        delete state.read;
        state = { ...state, ...next };
        continue;
    } else if ("mkdir" in state) {
        mkdir(fileSystem, join(workdir, parse(state.dir)));
        delete state.mkdir;
    } else if ("write" in state) {
        write(fileSystem, join(workdir, parse(state.file)), state.contents);
        delete state.write;
    } else if ("ls" in state) {
        let dir = get(fileSystem, join(workdir, parse(state.path)));
        if (dir instanceof Map)
            console.log(Object.keys(dir).join("\t"));
        else if (dir === undefined)
            console.log(`${state.path}: no such file or directory`);
        else
            console.log(state.path);
        delete state.ls;
    } else if ("id" in state) {
        console.log("uid=1000(user) gid=100(users) groups=100(users),25(floppy)");
        delete state.id;
    } else if ("cat" in state) {
        let file = get(fileSystem, join(workdir, parse(state.file)));
        if (file instanceof Map)
            console.log(`${state.path}: is a directory`);
        else if (file === undefined)
            console.log(`${state.path}: no such file or directory`);
        else
            console.log(file);
        delete state.cat;
    } else if ("checkpassword" in state) {
        let next = (await Bun.password.verify(
            state.password,
            "$argon2id$v=19$m=65536,t=2,p=1$nGJgXijpFTZf+xPlduAKQr84I+r0/kkZ3KBQ568IQSw$CqhQyf+b6wnNNwVs90hQLqnAbuAlp8PsloOy2n9MeGQ",
        ))
            ? state.checkpassword.next
            : {};
        delete state.checkpassword;
        state = { ...state, ...next };
        continue;
    } else if ("writeflag" in state) {
        write(fileSystem, join(workdir, parse(state.file)), Bun.env.FLAG ?? "ingen flagga!?!?!?");
        delete state.writeflag;
    } else if ("cd" in state) {
        let path = join(workdir, parse(state.path));
        if (get(fileSystem, path) instanceof Map)
            workdir = path;
        else
            console.log(`the directory ${state.path} does not exist`);
        delete state.cd;
    } else if ("pwd" in state) {
        console.log("/" + workdir.segments.join("/"));
        delete state.pwd;
    }
    let line = await readword("$ ");
    if (line === undefined) break;
    switch (line) {
        case "mkdir": state.read = { dest: "dir", next: { mkdir: undefined } }; break;
        case "write": state.read = { dest: "file", next: { read: { dest: "contents", next: { write: undefined } } } }; break;
        case "ls": state.read = { dest: "path", next: { ls: undefined } }; break;
        case "id": state.id = undefined; break;
        case "cat": state.read = { dest: "file", next: { cat: undefined } }; break;
        case "writeflag": state.read = { dest: "password", next: { checkpassword: { next: { read: { dest: "file", next: { writeflag: undefined } } } } } }; break;
        case "cd": state.read = { dest: "path", next: { cd: undefined } }; break;
        case "pwd": state.pwd = undefined; break;
        case "": break;
        default: throw new Error(`command ${line} not found`); break;
    }
}
