# Heapie

Heap, fast lite hippie eftersom `malloc` inte är inblandat.

I programmet kan man spara stycken (som är textsträngar) och dokument (som är listor av stycken).
När man tar bort dessa frigörs dem i minnesallokatorn, men pekarna ligger kvar.

Det är ju ett problem, men både `std.heap.GeneralPurposeAllocator` och `std.heap.page_allocator` ska
aldrig ge samma adress två gånger, även om de deallokerats emellanåt. `page_allocator`s metod för
detta är att när den anropar `mmap` alltid fråga kernelen om den kan få adressen 4096 bytes efter
senaste allokeringen. Om man inte frågar `mmap` om en specifik adress verkar den däremot ge
adresser 4096 bytes "innan" senaste allokeringen, alltså växer de åt "fel" håll. När programmet
anropar `std.posix.mmap` i början för att mappa in flaggan placeras den på en adress vi kan kalla
`x`. När `std.heap.page_allocator` sedan anropar `mmap` för första gången görs det också utan att
fråga efter en specifik adress och då placeras den på `x - 4096`. Vid nästa anrop till `mmap`
kommer `std.heap.page_allocator` fråga om adressen `x - 4096 + 4096 = x`, men eftersom den redan är
allokerad ignoreras detta och allokeringen placeras på nästa lediga adress, `x - 4096 - 4096`.
Detta gör att att om en allokering till `std.heap.page_allocator` görs vartefter den frigörs och en
ny tillfrågas kommer dessa två få samma adress (vilket också är vad som brukar hända om man anropar
`mmap` utan att fråga om en specifik adress).

Även `std.heap.GeneralPurposeAllocator` är menad att aldrig ge två allokeringar samma adress. Den
lägger allokeringar i olika buckets beroende på storlek (1, 2, 4, 8, ..., 2048 bytes. Större
allokeringar går direkt till `std.heap.page_allocator` men så stora allokeringar tillåts man inte
göra för stycken eller dokument). Varje bucket består av ett godtyckligt antal pages som allokeras
från `std.heap.page_allocator`. När en plats i en bucket frigörs kommer den inte lämnas ut i
framtida allokeringar men när alla allokeringar i en page blir frigjorda kommer hela pagen att
frigöras, vilket tillsammans med det i stycken ovan gör att man kan få tillbaks samma adress flera
gånger.

Taskigt nog så allokeras det en gång i varje bucket när programmet startar, så att allokera,
deallokera och igen allokera (med samma storlek) på en gång leder inte till att de får samma adress.
Om man däremot allokerar i en bucket så att den fylls upp helt (de är 4096 bytes på Linux), sedan
allokerar, deallokerar och igen allokerar (med samma storlek) så ges samma adress.

Målet är att få ett stycke och ett dokument som ligger på samma adress, vilket kan göras med att
allokera ett stycke på 16 bytes, deallokera det, och sedan allokera ett dokument med ett stycke,
(samma stycke som man nyss frigjorde). Om då skriver ut stycket får man 8 bytes som är adressen till
stycket sen 8 bytes som är längden (alltså 16), eftersom det skrivits över med dokumentet. Därefter
vet man att flaggan som laddades in i början kommer vara ett antal pages efter stycket. Om man nu
skriver över stycket kan man t.ex ge den adressen till stycket man skrev ut plus 4096 multiplicerat
med godtyckligt tal följt av 4096 så dokumentet peka till en adress så många pages senare. Skrivs
dokumentet ut skrivs den pagen ut. Upprepa med godtyckliga tal, typ 1-100 så skrivs flaggan till
slut ut.

Skulle kunna göras svårare genom att man själv får välja adressen flaggan ska `mmap`pas till (då
lösningen skulle var att ange 0), men det behövs nog inte.
