#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <time.h>
#include <unistd.h>
#include <inttypes.h>
#include <asm/unistd.h>
#include <linux/perf_event.h>
#include <sys/types.h>
#include <sys/ioctl.h>

static long perf_event_open(struct perf_event_attr *hw_event, pid_t pid, int cpu, int group_fd, unsigned long flags)
{
    int ret;

    ret = syscall(__NR_perf_event_open, hw_event, pid, cpu, group_fd, flags);
    return ret;
}

struct timespec sleep_time;
char flag[] = "cratectf{strcmp_daligt_for_losenord}";
bool debug = false;
bool fast_mode = false;

// Junk variables for fake options
bool locale = false;
bool flag_endian = false;
bool aslr = true;

unsigned long long instructions_count = 0;

// Exits as soon as an incorrect character is found, vulnerable to timing attack
int strcmp_early_exit(const char *s1, const char *s2)
{
    for (int i = 0;; i++)
    {
        // Hardware performance counters does not seem to work in Docker, so we'll just fake it
        instructions_count += 4;
        if (s1[i] != s2[i])
            return 1;
        if (s1[i] == 0 && s2[i] == 0)
            return 0;
    }
}

// Continues to compare characters until the end of one of the inputs.
// Runs in (near) constant time for any input of a given length
int strcmp_constant_time(const char *s1, const char *s2)
{
    bool correct = true;
    for (int i = 0;; i++)
    {
        // Hardware performance counters does not seem to work in Docker, so we'll just fake it
        instructions_count += 8;
        if (s1[i] == 0 || s2[i] == 0)
            return 1;
        if (s1[i] != s2[i])
            correct = false;
        if (s1[i] == 0 && s2[i] == 0)
            return correct;
    }
}

int main()
{
    setvbuf(stdout, 0, 2, 0);
    setvbuf(stdin, 0, 2, 0);

    while (true)
    {
        puts("== Flag verifier ==");
        puts(" Menu options:");
        puts("  (1) Check flag");
        puts("  (2) Options");
        puts("  (0) Quit");
        printf("Enter action: ");

        char action[3] = "";

        if (!fgets(action, sizeof(action), stdin))
            exit(0);
        switch (action[0])
        {
        case '0':
        {
            puts("Bye!");
            exit(0);
            break;
        }
        case '1':
        {
            printf("Enter flag: ");

            char entered_flag[64] = "";

            if (!fgets(entered_flag, sizeof(entered_flag) - 1, stdin))
                exit(0);
            puts("");

            entered_flag[strcspn(entered_flag, "\n")] = 0;

            // struct perf_event_attr pe;
            // long long instructions_count;
            // int fd;
            // memset(&pe, 0, sizeof(struct perf_event_attr));
            // pe.type = PERF_TYPE_HARDWARE;
            // pe.size = sizeof(struct perf_event_attr);
            // pe.config = PERF_COUNT_HW_INSTRUCTIONS;
            // pe.disabled = 1;
            // pe.exclude_kernel = 1;
            // // Don't count hypervisor events.
            // pe.exclude_hv = 1;

            // fd = perf_event_open(&pe, 0, -1, -1, 0);
            // if (fd == -1)
            // {
            //     fprintf(stderr, "Error opening leader %llx\n", pe.config);
            //     exit(EXIT_FAILURE);
            // }

            // ioctl(fd, PERF_EVENT_IOC_RESET, 0);
            // ioctl(fd, PERF_EVENT_IOC_ENABLE, 0);

            // Hardware performance counters does not seem to work in Docker, so we'll just fake it
            instructions_count = 40;

            int result;
            if (fast_mode)
                result = strcmp_early_exit(entered_flag, flag);
            else
                result = strcmp_constant_time(entered_flag, flag);

            // ioctl(fd, PERF_EVENT_IOC_DISABLE, 0);
            // read(fd, &instructions_count, sizeof(long long));

            // close(fd);

            if (result == 0)
            {
                puts("That is the correct flag!");
            }
            else
            {
                puts("Incorrect flag!");
                if (debug)
                {
                    printf("Backend server: srv-prod%d.crate.nu\n", rand() % 4 + 1);
                    printf("Process ID: %d\n", getpid());
                    printf("Total query time: %llu us\n", instructions_count);
                }
            }
            break;
        }
        case '2':
        {
            while (true)
            {
                puts(" Settings:");
                printf("  (1) Optimizations: %s\n", fast_mode ? "enabled" : "disabled");
                printf("  (2) Flag locale: %s\n", locale ? "sv_SE" : "en_US");
                printf("  (3) Flag endianness: %s\n", flag_endian ? "big" : "little");
                printf("  (4) ASLR: %s\n", aslr ? "enabled" : "disabled");
                printf("  (5) Debug mode: %s\n", debug ? "enabled" : "disabled");
                puts("  (0) Return");
                printf("Enter action: ");

                char action[3] = "";

                if (!fgets(action, sizeof(action), stdin) || action[0] == '0')
                    break;
                puts("");
                switch (action[0])
                {
                case '1':
                {
                    fast_mode = !fast_mode;
                    break;
                }
                case '2':
                {
                    locale = !locale;
                    break;
                }
                case '3':
                {
                    flag_endian = !flag_endian;
                    break;
                }
                case '4':
                {
                    aslr = !aslr;
                    break;
                }
                case '5':
                {
                    debug = !debug;
                    break;
                }
                }
            }
        }
        }
        puts("");
    }
}